** Question
   :PROPERTIES:
   :CUSTOM_ID: question
   :END:

Elf Web Access (EWA) is the preferred mailer for North Pole elves,
available internally at http://mail.northpolechristmastown.com. What
can you learn from The Great Book page found in an e-mail on that
server?

** Background Information
   :PROPERTIES:
   :CUSTOM_ID: background-information
   :END:

Do we know anything about this system already?

Hints:

List any useful hints here.

Blog Posts:

Are any of these useful?

- Putting My Zero Cents In: Using the Free Tier on Amazon Web Services
  (EC2)
  https://pen-testing.sans.org/blog/2017/12/10/putting-my-zero-cents-in-using-the-free-tier-on-amazon-web-services-ec2
  Spinning up an EC2 instance, but also a lot of emphasis on how to use
  SSH keys.
- Your Pokemon Guide for Essential SQL Pen Test Commands
  https://pen-testing.sans.org/blog/2017/12/09/your-pokemon-guide-for-essential-sql-pen-test-commands
  SQL basics (SELECT, WHERE, wildcards, ORDER BY, GROUP BY, COUNT)
- Exploiting XXE Vulnerabilities in IIS/.NET
  https://pen-testing.sans.org/blog/2017/12/08/entity-inception-exploiting-iis-net-with-xxe-vulnerabilities
  Including remote content in XML
- Why You Need the Skills to Tinker with Publicly Released Exploit Code
  https://pen-testing.sans.org/blog/2017/12/05/why-you-need-the-skills-to-tinker-with-publicly-released-exploit-code
  Mentions Apache struts vulnerabilities, specifically CVE-2017-5638 and
  CVE-2017-9805 Code: https://github.com/chrisjd20/cve-2017-9805.py
- Go To The Head Of The Class: LD\_PRELOAD For The Win
  https://pen-testing.sans.org/blog/2017/12/06/go-to-the-head-of-the-class-ld-preload-for-the-win
- A Spot of Tee
  https://pen-testing.sans.org/blog/2017/12/06/a-spot-of-tee Restricted
  bash shell, and bypassing the I/O restriction with tee
- Understanding and Exploiting Web-based LDAP
  https://pen-testing.sans.org/blog/2017/11/27/understanding-and-exploiting-web-based-ldap
  LDAP syntax, LDAP injection
- Massively Scaling your Scanning
  https://pen-testing.sans.org/blog/2017/10/25/massively-scaling-your-scanning
  masscan

** Goal
   :PROPERTIES:
   :CUSTOM_ID: goal
   :END:

What are we trying to accomplish?

** Approach
   :PROPERTIES:
   :CUSTOM_ID: approach
   :END:

Describe the thought process that we tried here. How were we able to use
the hints or the blog posts?

** Solution
   :PROPERTIES:
   :CUSTOM_ID: solution
   :END:

Summarize the reference solution that we found

*** How to forge a session cookie

#+BEGIN_QUOTE
Happy families are all alike; every unhappy family is unhappy in its own way. --   Leo Tolstoy
#+END_QUOTE

#+BEGIN_QUOTE
Empty plaintext encrypted without using HMAC are all alike; Rolling your own crypto makes all cryptographers unhappy. -- Justin Azoff
#+END_QUOTE

The js code they use is a variation of a challenge response algorithm, but it
is flawed in that the client is providing both the challenge and the response.
It is also flawed in that it does not use MAC https://en.wikipedia.org/wiki/Authenticated_encryption#MAC-then-Encrypt_(MtE)
meaning that the encrypted contents themselves are never verified.

Since we can control both the ciphertext and the expected plaintext, we can
just set the challenge to the empty string "" and the response then just needs
to be ANY message that decrypts to "".  Since the message is empty, the key is
irrelevant, we just need to work out how to properly generate a ciphertext that
will decrypt to nothing.

A completly empty ciphertext throws an error:

#+BEGIN_SRC js
> var aes256 = require('aes256');
> aes256.decrypt('key does not matter', '')
TypeError: Provided "encrypted" must be a non-empty string
    at Object.decrypt (/Users/user/node_modules/aes256/index.js:68:13)
#+END_SRC

A larger ciphertext works, but gives us a random string, which is not what we want.. but 
we can see that a fairly long cipher text only gives us a few bytes of plaintext...

#+BEGIN_SRC js
> aes256.decrypt('key does not matter', 'aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa')
'F..%=X..'
#+END_SRC

The difference in the length of the two strings is 24:

#+BEGIN_SRC js
> x='aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa'
> x.length - aes256.decrypt('key does not matter',x).length
24
#+END_SRC

From the hints, we learn that some of the bytes are used for the IV.

The aes library won't let us encrypt an empty string, but we can encrypt a single char:

#+BEGIN_SRC js
> aes256.encrypt('key does not matter', '')
TypeError: Provided "plaintext" must be a non-empty string
    at Object.encrypt (/Users/user/node_modules/aes256/index.js:39:13)
> aes256.encrypt('key does not matter', 'x')
'L7rwNMwISl2chavT6lILlNM='
> aes256.encrypt('key does not matter', 'x').length
24
#+END_SRC

This gives a ciphertext of length 24 with one byte of = for padding.  This
means that 22 bytes are used for the IV and one byte is used to encrypt the 'x'
itself.

So, at this point it is clear that something interesting happens around 22-24 chars.

Trying different lengths approaching a length of 22 continues to throw an error
for a while...

#+BEGIN_SRC js
> aes256.decrypt('key does not matter', 'aaaaaaaaaaaaaaaa')
TypeError: Provided "encrypted" must be a non-empty string
    at Object.decrypt (/Users/user/node_modules/aes256/index.js:68:13)
#+END_SRC

Until the error changes:

#+BEGIN_SRC js
> aes256.decrypt('key does not matter', 'aaaaaaaaaaaaaaaaa')
Error: Invalid IV length
    at new Decipheriv (internal/crypto/cipher.js:186:16)
    at Object.createDecipheriv (crypto.js:106:10)
    at Object.decrypt (/Users/user/node_modules/aes256/index.js:78:27)
> aes256.decrypt('key does not matter', 'aaaaaaaaaaaaaaaaaa')
Error: Invalid IV length
    at new Decipheriv (internal/crypto/cipher.js:186:16)
    at Object.createDecipheriv (crypto.js:106:10)
    at Object.decrypt (/Users/user/node_modules/aes256/index.js:78:27)
> aes256.decrypt('key does not matter', 'aaaaaaaaaaaaaaaaaaa')
Error: Invalid IV length
    at new Decipheriv (internal/crypto/cipher.js:186:16)
    at Object.createDecipheriv (crypto.js:106:10)
    at Object.decrypt (/Users/user/node_modules/aes256/index.js:78:27)
> aes256.decrypt('key does not matter', 'aaaaaaaaaaaaaaaaaaaa')
Error: Invalid IV length
    at new Decipheriv (internal/crypto/cipher.js:186:16)
    at Object.createDecipheriv (crypto.js:106:10)
    at Object.decrypt (/Users/user/node_modules/aes256/index.js:78:27)
> aes256.decrypt('key does not matter', 'aaaaaaaaaaaaaaaaaaaaa')
Error: Invalid IV length
    at new Decipheriv (internal/crypto/cipher.js:186:16)
    at Object.createDecipheriv (crypto.js:106:10)
    at Object.decrypt (/Users/user/node_modules/aes256/index.js:78:27)
> aes256.decrypt('key does not matter', 'aaaaaaaaaaaaaaaaaaaaaa')
''
> 'aaaaaaaaaaaaaaaaaaaaaa'.length
22
> aes256.decrypt('key really does not matter', 'aaaaaaaaaaaaaaaaaaaaaa')
''
#+END_SRC

Success!  A string of any 22 chars will decrypt to the empty string.

An alternative approach would be to edit the aes library and comment out this block:

#+BEGIN_SRC js
if (typeof plaintext !== 'string' || !plaintext) {
  throw new TypeError('Provided "plaintext" must be a non-empty string');
}
#+END_SRC

With the throw commented out, we can encrypt an empty string:

#+BEGIN_SRC js
> var aes256 = require('aes256');
> aes256.encrypt('whatever', '')
'SStLU1QxLjmtG/Ea8hMH0Q=='
> ct=aes256.encrypt('whatever', '')
'tYcVb4PRsdq4JWl5XMSNgw=='
> aes256.decrypt('a different key entirely', ct)
''
> ct.length
24
#+END_SRC

The length is different(24 instead of 22), but only because it is padded with 2
bytes of == for base64 purposes.

** Alternatives
   :PROPERTIES:
   :CUSTOM_ID: alternatives
   :END:

Any other, easier solutions?

** Common Pitfalls
   :PROPERTIES:
   :CUSTOM_ID: common-pitfalls
   :END:

Do we know what issue(s) people were running into?

** About the Challenge
   :PROPERTIES:
   :CUSTOM_ID: about-the-challenge
   :END:

How was the challenge setup? Was there a better way to secure this
system?
